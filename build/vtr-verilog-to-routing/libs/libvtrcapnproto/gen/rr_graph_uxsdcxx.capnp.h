// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: rr_graph_uxsdcxx.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>

#if CAPNP_VERSION != 9001
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif


CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(854301e7f06b01e0);
enum class SwitchType_854301e7f06b01e0: uint16_t {
  UXSD_INVALID,
  MUX,
  TRISTATE,
  PASS_GATE,
  SHORT,
  BUFFER,
};
CAPNP_DECLARE_ENUM(SwitchType, 854301e7f06b01e0);
CAPNP_DECLARE_SCHEMA(90627859fdf4877b);
enum class PinType_90627859fdf4877b: uint16_t {
  UXSD_INVALID,
  OPEN,
  OUTPUT,
  INPUT,
};
CAPNP_DECLARE_ENUM(PinType, 90627859fdf4877b);
CAPNP_DECLARE_SCHEMA(c79abad8705ce7d3);
enum class NodeType_c79abad8705ce7d3: uint16_t {
  UXSD_INVALID,
  CHANX,
  CHANY,
  SOURCE,
  SINK,
  OPIN,
  IPIN,
};
CAPNP_DECLARE_ENUM(NodeType, c79abad8705ce7d3);
CAPNP_DECLARE_SCHEMA(d15acf2f660d96fe);
enum class NodeDirection_d15acf2f660d96fe: uint16_t {
  UXSD_INVALID,
  INC_DIR,
  DEC_DIR,
  BI_DIR,
};
CAPNP_DECLARE_ENUM(NodeDirection, d15acf2f660d96fe);
CAPNP_DECLARE_SCHEMA(8e4cac4ed480211a);
enum class LocSide_8e4cac4ed480211a: uint16_t {
  UXSD_INVALID,
  LEFT,
  RIGHT,
  TOP,
  BOTTOM,
  RIGHT_LEFT,
  RIGHT_BOTTOM,
  RIGHT_BOTTOM_LEFT,
  TOP_RIGHT,
  TOP_BOTTOM,
  TOP_LEFT,
  TOP_RIGHT_BOTTOM,
  TOP_RIGHT_LEFT,
  TOP_BOTTOM_LEFT,
  TOP_RIGHT_BOTTOM_LEFT,
  BOTTOM_LEFT,
};
CAPNP_DECLARE_ENUM(LocSide, 8e4cac4ed480211a);
CAPNP_DECLARE_SCHEMA(b3ac93d519d72e2e);
CAPNP_DECLARE_SCHEMA(b27792e17a3fed34);
CAPNP_DECLARE_SCHEMA(863e5872f57df4e0);
CAPNP_DECLARE_SCHEMA(9282333865e5bcf9);
CAPNP_DECLARE_SCHEMA(d330ea8930eb55b4);
CAPNP_DECLARE_SCHEMA(9ef5606adf43c4bb);
CAPNP_DECLARE_SCHEMA(d7ae6dc27d2aaaa1);
CAPNP_DECLARE_SCHEMA(c98df160ebec5846);
CAPNP_DECLARE_SCHEMA(9a7ae0e83fa47378);
CAPNP_DECLARE_SCHEMA(e993ce9e4cbf3f3c);
CAPNP_DECLARE_SCHEMA(adb1195070c1c04f);
CAPNP_DECLARE_SCHEMA(d4031e7ef02e9159);
CAPNP_DECLARE_SCHEMA(d63c7499ab6de9b5);
CAPNP_DECLARE_SCHEMA(a53177008d08ddbf);
CAPNP_DECLARE_SCHEMA(9129770cca2918df);
CAPNP_DECLARE_SCHEMA(d812d43c9ade3226);
CAPNP_DECLARE_SCHEMA(ae0032574611054a);
CAPNP_DECLARE_SCHEMA(dd8c99154a2702e0);
CAPNP_DECLARE_SCHEMA(c91e489f14db2f52);
CAPNP_DECLARE_SCHEMA(a8eaef23ffd856f1);
CAPNP_DECLARE_SCHEMA(9c9e0023310e7110);
CAPNP_DECLARE_SCHEMA(9cd291f4f748bfd1);
CAPNP_DECLARE_SCHEMA(9de88fd938a89598);
CAPNP_DECLARE_SCHEMA(dd14332233a9cfbe);
CAPNP_DECLARE_SCHEMA(d6e58dd73383213e);
CAPNP_DECLARE_SCHEMA(9fd7e8ae0321663b);
CAPNP_DECLARE_SCHEMA(f5c3de62d3a08dbc);

}  // namespace schemas
}  // namespace capnp

namespace ucap {

typedef ::capnp::schemas::SwitchType_854301e7f06b01e0 SwitchType;

typedef ::capnp::schemas::PinType_90627859fdf4877b PinType;

typedef ::capnp::schemas::NodeType_c79abad8705ce7d3 NodeType;

typedef ::capnp::schemas::NodeDirection_d15acf2f660d96fe NodeDirection;

typedef ::capnp::schemas::LocSide_8e4cac4ed480211a LocSide;

struct Channel {
  Channel() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b3ac93d519d72e2e, 3, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct XList {
  XList() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b27792e17a3fed34, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct YList {
  YList() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(863e5872f57df4e0, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Channels {
  Channels() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9282333865e5bcf9, 0, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Timing {
  Timing() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d330ea8930eb55b4, 3, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Sizing {
  Sizing() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9ef5606adf43c4bb, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Switch {
  Switch() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d7ae6dc27d2aaaa1, 1, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Switches {
  Switches() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c98df160ebec5846, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct SegmentTiming {
  SegmentTiming() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9a7ae0e83fa47378, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Segment {
  Segment() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e993ce9e4cbf3f3c, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Segments {
  Segments() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(adb1195070c1c04f, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Pin {
  Pin() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d4031e7ef02e9159, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct PinClass {
  PinClass() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d63c7499ab6de9b5, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct BlockType {
  BlockType() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a53177008d08ddbf, 2, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct BlockTypes {
  BlockTypes() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9129770cca2918df, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct GridLoc {
  GridLoc() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d812d43c9ade3226, 3, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct GridLocs {
  GridLocs() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ae0032574611054a, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct NodeLoc {
  NodeLoc() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(dd8c99154a2702e0, 3, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct NodeTiming {
  NodeTiming() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c91e489f14db2f52, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct NodeSegment {
  NodeSegment() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a8eaef23ffd856f1, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Meta {
  Meta() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9c9e0023310e7110, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Metadata {
  Metadata() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9cd291f4f748bfd1, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Node {
  Node() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9de88fd938a89598, 2, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct RrNodes {
  RrNodes() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(dd14332233a9cfbe, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Edge {
  Edge() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d6e58dd73383213e, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct RrEdges {
  RrEdges() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9fd7e8ae0321663b, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct RrGraph {
  RrGraph() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f5c3de62d3a08dbc, 0, 10)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class Channel::Reader {
public:
  typedef Channel Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int32_t getChanWidthMax() const;

  inline  ::int32_t getXMax() const;

  inline  ::int32_t getXMin() const;

  inline  ::int32_t getYMax() const;

  inline  ::int32_t getYMin() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Channel::Builder {
public:
  typedef Channel Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int32_t getChanWidthMax();
  inline void setChanWidthMax( ::int32_t value);

  inline  ::int32_t getXMax();
  inline void setXMax( ::int32_t value);

  inline  ::int32_t getXMin();
  inline void setXMin( ::int32_t value);

  inline  ::int32_t getYMax();
  inline void setYMax( ::int32_t value);

  inline  ::int32_t getYMin();
  inline void setYMin( ::int32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Channel::Pipeline {
public:
  typedef Channel Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class XList::Reader {
public:
  typedef XList Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getIndex() const;

  inline  ::int32_t getInfo() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class XList::Builder {
public:
  typedef XList Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getIndex();
  inline void setIndex( ::uint32_t value);

  inline  ::int32_t getInfo();
  inline void setInfo( ::int32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class XList::Pipeline {
public:
  typedef XList Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class YList::Reader {
public:
  typedef YList Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getIndex() const;

  inline  ::int32_t getInfo() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class YList::Builder {
public:
  typedef YList Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getIndex();
  inline void setIndex( ::uint32_t value);

  inline  ::int32_t getInfo();
  inline void setInfo( ::int32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class YList::Pipeline {
public:
  typedef YList Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Channels::Reader {
public:
  typedef Channels Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasChannel() const;
  inline  ::ucap::Channel::Reader getChannel() const;

  inline bool hasXLists() const;
  inline  ::capnp::List< ::ucap::XList,  ::capnp::Kind::STRUCT>::Reader getXLists() const;

  inline bool hasYLists() const;
  inline  ::capnp::List< ::ucap::YList,  ::capnp::Kind::STRUCT>::Reader getYLists() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Channels::Builder {
public:
  typedef Channels Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasChannel();
  inline  ::ucap::Channel::Builder getChannel();
  inline void setChannel( ::ucap::Channel::Reader value);
  inline  ::ucap::Channel::Builder initChannel();
  inline void adoptChannel(::capnp::Orphan< ::ucap::Channel>&& value);
  inline ::capnp::Orphan< ::ucap::Channel> disownChannel();

  inline bool hasXLists();
  inline  ::capnp::List< ::ucap::XList,  ::capnp::Kind::STRUCT>::Builder getXLists();
  inline void setXLists( ::capnp::List< ::ucap::XList,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::ucap::XList,  ::capnp::Kind::STRUCT>::Builder initXLists(unsigned int size);
  inline void adoptXLists(::capnp::Orphan< ::capnp::List< ::ucap::XList,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::ucap::XList,  ::capnp::Kind::STRUCT>> disownXLists();

  inline bool hasYLists();
  inline  ::capnp::List< ::ucap::YList,  ::capnp::Kind::STRUCT>::Builder getYLists();
  inline void setYLists( ::capnp::List< ::ucap::YList,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::ucap::YList,  ::capnp::Kind::STRUCT>::Builder initYLists(unsigned int size);
  inline void adoptYLists(::capnp::Orphan< ::capnp::List< ::ucap::YList,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::ucap::YList,  ::capnp::Kind::STRUCT>> disownYLists();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Channels::Pipeline {
public:
  typedef Channels Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::ucap::Channel::Pipeline getChannel();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Timing::Reader {
public:
  typedef Timing Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline float getCin() const;

  inline float getCinternal() const;

  inline float getCout() const;

  inline float getR() const;

  inline float getTdel() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Timing::Builder {
public:
  typedef Timing Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline float getCin();
  inline void setCin(float value);

  inline float getCinternal();
  inline void setCinternal(float value);

  inline float getCout();
  inline void setCout(float value);

  inline float getR();
  inline void setR(float value);

  inline float getTdel();
  inline void setTdel(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Timing::Pipeline {
public:
  typedef Timing Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Sizing::Reader {
public:
  typedef Sizing Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline float getBufSize() const;

  inline float getMuxTransSize() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Sizing::Builder {
public:
  typedef Sizing Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline float getBufSize();
  inline void setBufSize(float value);

  inline float getMuxTransSize();
  inline void setMuxTransSize(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Sizing::Pipeline {
public:
  typedef Sizing Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Switch::Reader {
public:
  typedef Switch Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int32_t getId() const;

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

  inline  ::ucap::SwitchType getType() const;

  inline bool hasTiming() const;
  inline  ::ucap::Timing::Reader getTiming() const;

  inline bool hasSizing() const;
  inline  ::ucap::Sizing::Reader getSizing() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Switch::Builder {
public:
  typedef Switch Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int32_t getId();
  inline void setId( ::int32_t value);

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

  inline  ::ucap::SwitchType getType();
  inline void setType( ::ucap::SwitchType value);

  inline bool hasTiming();
  inline  ::ucap::Timing::Builder getTiming();
  inline void setTiming( ::ucap::Timing::Reader value);
  inline  ::ucap::Timing::Builder initTiming();
  inline void adoptTiming(::capnp::Orphan< ::ucap::Timing>&& value);
  inline ::capnp::Orphan< ::ucap::Timing> disownTiming();

  inline bool hasSizing();
  inline  ::ucap::Sizing::Builder getSizing();
  inline void setSizing( ::ucap::Sizing::Reader value);
  inline  ::ucap::Sizing::Builder initSizing();
  inline void adoptSizing(::capnp::Orphan< ::ucap::Sizing>&& value);
  inline ::capnp::Orphan< ::ucap::Sizing> disownSizing();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Switch::Pipeline {
public:
  typedef Switch Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::ucap::Timing::Pipeline getTiming();
  inline  ::ucap::Sizing::Pipeline getSizing();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Switches::Reader {
public:
  typedef Switches Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasSwitches() const;
  inline  ::capnp::List< ::ucap::Switch,  ::capnp::Kind::STRUCT>::Reader getSwitches() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Switches::Builder {
public:
  typedef Switches Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasSwitches();
  inline  ::capnp::List< ::ucap::Switch,  ::capnp::Kind::STRUCT>::Builder getSwitches();
  inline void setSwitches( ::capnp::List< ::ucap::Switch,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::ucap::Switch,  ::capnp::Kind::STRUCT>::Builder initSwitches(unsigned int size);
  inline void adoptSwitches(::capnp::Orphan< ::capnp::List< ::ucap::Switch,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::ucap::Switch,  ::capnp::Kind::STRUCT>> disownSwitches();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Switches::Pipeline {
public:
  typedef Switches Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class SegmentTiming::Reader {
public:
  typedef SegmentTiming Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline float getCPerMeter() const;

  inline float getRPerMeter() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class SegmentTiming::Builder {
public:
  typedef SegmentTiming Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline float getCPerMeter();
  inline void setCPerMeter(float value);

  inline float getRPerMeter();
  inline void setRPerMeter(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class SegmentTiming::Pipeline {
public:
  typedef SegmentTiming Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Segment::Reader {
public:
  typedef Segment Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int32_t getId() const;

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

  inline bool hasTiming() const;
  inline  ::ucap::SegmentTiming::Reader getTiming() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Segment::Builder {
public:
  typedef Segment Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int32_t getId();
  inline void setId( ::int32_t value);

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

  inline bool hasTiming();
  inline  ::ucap::SegmentTiming::Builder getTiming();
  inline void setTiming( ::ucap::SegmentTiming::Reader value);
  inline  ::ucap::SegmentTiming::Builder initTiming();
  inline void adoptTiming(::capnp::Orphan< ::ucap::SegmentTiming>&& value);
  inline ::capnp::Orphan< ::ucap::SegmentTiming> disownTiming();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Segment::Pipeline {
public:
  typedef Segment Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::ucap::SegmentTiming::Pipeline getTiming();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Segments::Reader {
public:
  typedef Segments Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasSegments() const;
  inline  ::capnp::List< ::ucap::Segment,  ::capnp::Kind::STRUCT>::Reader getSegments() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Segments::Builder {
public:
  typedef Segments Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasSegments();
  inline  ::capnp::List< ::ucap::Segment,  ::capnp::Kind::STRUCT>::Builder getSegments();
  inline void setSegments( ::capnp::List< ::ucap::Segment,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::ucap::Segment,  ::capnp::Kind::STRUCT>::Builder initSegments(unsigned int size);
  inline void adoptSegments(::capnp::Orphan< ::capnp::List< ::ucap::Segment,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::ucap::Segment,  ::capnp::Kind::STRUCT>> disownSegments();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Segments::Pipeline {
public:
  typedef Segments Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Pin::Reader {
public:
  typedef Pin Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int32_t getPtc() const;

  inline bool hasValue() const;
  inline  ::capnp::Text::Reader getValue() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Pin::Builder {
public:
  typedef Pin Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int32_t getPtc();
  inline void setPtc( ::int32_t value);

  inline bool hasValue();
  inline  ::capnp::Text::Builder getValue();
  inline void setValue( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initValue(unsigned int size);
  inline void adoptValue(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownValue();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Pin::Pipeline {
public:
  typedef Pin Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class PinClass::Reader {
public:
  typedef PinClass Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::ucap::PinType getType() const;

  inline bool hasPins() const;
  inline  ::capnp::List< ::ucap::Pin,  ::capnp::Kind::STRUCT>::Reader getPins() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class PinClass::Builder {
public:
  typedef PinClass Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::ucap::PinType getType();
  inline void setType( ::ucap::PinType value);

  inline bool hasPins();
  inline  ::capnp::List< ::ucap::Pin,  ::capnp::Kind::STRUCT>::Builder getPins();
  inline void setPins( ::capnp::List< ::ucap::Pin,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::ucap::Pin,  ::capnp::Kind::STRUCT>::Builder initPins(unsigned int size);
  inline void adoptPins(::capnp::Orphan< ::capnp::List< ::ucap::Pin,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::ucap::Pin,  ::capnp::Kind::STRUCT>> disownPins();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class PinClass::Pipeline {
public:
  typedef PinClass Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class BlockType::Reader {
public:
  typedef BlockType Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int32_t getHeight() const;

  inline  ::int32_t getId() const;

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

  inline  ::int32_t getWidth() const;

  inline bool hasPinClasses() const;
  inline  ::capnp::List< ::ucap::PinClass,  ::capnp::Kind::STRUCT>::Reader getPinClasses() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class BlockType::Builder {
public:
  typedef BlockType Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int32_t getHeight();
  inline void setHeight( ::int32_t value);

  inline  ::int32_t getId();
  inline void setId( ::int32_t value);

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

  inline  ::int32_t getWidth();
  inline void setWidth( ::int32_t value);

  inline bool hasPinClasses();
  inline  ::capnp::List< ::ucap::PinClass,  ::capnp::Kind::STRUCT>::Builder getPinClasses();
  inline void setPinClasses( ::capnp::List< ::ucap::PinClass,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::ucap::PinClass,  ::capnp::Kind::STRUCT>::Builder initPinClasses(unsigned int size);
  inline void adoptPinClasses(::capnp::Orphan< ::capnp::List< ::ucap::PinClass,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::ucap::PinClass,  ::capnp::Kind::STRUCT>> disownPinClasses();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class BlockType::Pipeline {
public:
  typedef BlockType Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class BlockTypes::Reader {
public:
  typedef BlockTypes Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasBlockTypes() const;
  inline  ::capnp::List< ::ucap::BlockType,  ::capnp::Kind::STRUCT>::Reader getBlockTypes() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class BlockTypes::Builder {
public:
  typedef BlockTypes Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasBlockTypes();
  inline  ::capnp::List< ::ucap::BlockType,  ::capnp::Kind::STRUCT>::Builder getBlockTypes();
  inline void setBlockTypes( ::capnp::List< ::ucap::BlockType,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::ucap::BlockType,  ::capnp::Kind::STRUCT>::Builder initBlockTypes(unsigned int size);
  inline void adoptBlockTypes(::capnp::Orphan< ::capnp::List< ::ucap::BlockType,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::ucap::BlockType,  ::capnp::Kind::STRUCT>> disownBlockTypes();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class BlockTypes::Pipeline {
public:
  typedef BlockTypes Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class GridLoc::Reader {
public:
  typedef GridLoc Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int32_t getBlockTypeId() const;

  inline  ::int32_t getHeightOffset() const;

  inline  ::int32_t getWidthOffset() const;

  inline  ::int32_t getX() const;

  inline  ::int32_t getY() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class GridLoc::Builder {
public:
  typedef GridLoc Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int32_t getBlockTypeId();
  inline void setBlockTypeId( ::int32_t value);

  inline  ::int32_t getHeightOffset();
  inline void setHeightOffset( ::int32_t value);

  inline  ::int32_t getWidthOffset();
  inline void setWidthOffset( ::int32_t value);

  inline  ::int32_t getX();
  inline void setX( ::int32_t value);

  inline  ::int32_t getY();
  inline void setY( ::int32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class GridLoc::Pipeline {
public:
  typedef GridLoc Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class GridLocs::Reader {
public:
  typedef GridLocs Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasGridLocs() const;
  inline  ::capnp::List< ::ucap::GridLoc,  ::capnp::Kind::STRUCT>::Reader getGridLocs() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class GridLocs::Builder {
public:
  typedef GridLocs Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasGridLocs();
  inline  ::capnp::List< ::ucap::GridLoc,  ::capnp::Kind::STRUCT>::Builder getGridLocs();
  inline void setGridLocs( ::capnp::List< ::ucap::GridLoc,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::ucap::GridLoc,  ::capnp::Kind::STRUCT>::Builder initGridLocs(unsigned int size);
  inline void adoptGridLocs(::capnp::Orphan< ::capnp::List< ::ucap::GridLoc,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::ucap::GridLoc,  ::capnp::Kind::STRUCT>> disownGridLocs();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class GridLocs::Pipeline {
public:
  typedef GridLocs Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class NodeLoc::Reader {
public:
  typedef NodeLoc Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int32_t getPtc() const;

  inline  ::ucap::LocSide getSide() const;

  inline  ::int32_t getXhigh() const;

  inline  ::int32_t getXlow() const;

  inline  ::int32_t getYhigh() const;

  inline  ::int32_t getYlow() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class NodeLoc::Builder {
public:
  typedef NodeLoc Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int32_t getPtc();
  inline void setPtc( ::int32_t value);

  inline  ::ucap::LocSide getSide();
  inline void setSide( ::ucap::LocSide value);

  inline  ::int32_t getXhigh();
  inline void setXhigh( ::int32_t value);

  inline  ::int32_t getXlow();
  inline void setXlow( ::int32_t value);

  inline  ::int32_t getYhigh();
  inline void setYhigh( ::int32_t value);

  inline  ::int32_t getYlow();
  inline void setYlow( ::int32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class NodeLoc::Pipeline {
public:
  typedef NodeLoc Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class NodeTiming::Reader {
public:
  typedef NodeTiming Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline float getC() const;

  inline float getR() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class NodeTiming::Builder {
public:
  typedef NodeTiming Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline float getC();
  inline void setC(float value);

  inline float getR();
  inline void setR(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class NodeTiming::Pipeline {
public:
  typedef NodeTiming Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class NodeSegment::Reader {
public:
  typedef NodeSegment Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int32_t getSegmentId() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class NodeSegment::Builder {
public:
  typedef NodeSegment Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int32_t getSegmentId();
  inline void setSegmentId( ::int32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class NodeSegment::Pipeline {
public:
  typedef NodeSegment Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Meta::Reader {
public:
  typedef Meta Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

  inline bool hasValue() const;
  inline  ::capnp::Text::Reader getValue() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Meta::Builder {
public:
  typedef Meta Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

  inline bool hasValue();
  inline  ::capnp::Text::Builder getValue();
  inline void setValue( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initValue(unsigned int size);
  inline void adoptValue(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownValue();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Meta::Pipeline {
public:
  typedef Meta Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Metadata::Reader {
public:
  typedef Metadata Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasMetas() const;
  inline  ::capnp::List< ::ucap::Meta,  ::capnp::Kind::STRUCT>::Reader getMetas() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Metadata::Builder {
public:
  typedef Metadata Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasMetas();
  inline  ::capnp::List< ::ucap::Meta,  ::capnp::Kind::STRUCT>::Builder getMetas();
  inline void setMetas( ::capnp::List< ::ucap::Meta,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::ucap::Meta,  ::capnp::Kind::STRUCT>::Builder initMetas(unsigned int size);
  inline void adoptMetas(::capnp::Orphan< ::capnp::List< ::ucap::Meta,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::ucap::Meta,  ::capnp::Kind::STRUCT>> disownMetas();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Metadata::Pipeline {
public:
  typedef Metadata Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Node::Reader {
public:
  typedef Node Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getCapacity() const;

  inline  ::ucap::NodeDirection getDirection() const;

  inline  ::uint32_t getId() const;

  inline  ::ucap::NodeType getType() const;

  inline bool hasLoc() const;
  inline  ::ucap::NodeLoc::Reader getLoc() const;

  inline bool hasTiming() const;
  inline  ::ucap::NodeTiming::Reader getTiming() const;

  inline bool hasSegment() const;
  inline  ::ucap::NodeSegment::Reader getSegment() const;

  inline bool hasMetadata() const;
  inline  ::ucap::Metadata::Reader getMetadata() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Node::Builder {
public:
  typedef Node Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getCapacity();
  inline void setCapacity( ::uint32_t value);

  inline  ::ucap::NodeDirection getDirection();
  inline void setDirection( ::ucap::NodeDirection value);

  inline  ::uint32_t getId();
  inline void setId( ::uint32_t value);

  inline  ::ucap::NodeType getType();
  inline void setType( ::ucap::NodeType value);

  inline bool hasLoc();
  inline  ::ucap::NodeLoc::Builder getLoc();
  inline void setLoc( ::ucap::NodeLoc::Reader value);
  inline  ::ucap::NodeLoc::Builder initLoc();
  inline void adoptLoc(::capnp::Orphan< ::ucap::NodeLoc>&& value);
  inline ::capnp::Orphan< ::ucap::NodeLoc> disownLoc();

  inline bool hasTiming();
  inline  ::ucap::NodeTiming::Builder getTiming();
  inline void setTiming( ::ucap::NodeTiming::Reader value);
  inline  ::ucap::NodeTiming::Builder initTiming();
  inline void adoptTiming(::capnp::Orphan< ::ucap::NodeTiming>&& value);
  inline ::capnp::Orphan< ::ucap::NodeTiming> disownTiming();

  inline bool hasSegment();
  inline  ::ucap::NodeSegment::Builder getSegment();
  inline void setSegment( ::ucap::NodeSegment::Reader value);
  inline  ::ucap::NodeSegment::Builder initSegment();
  inline void adoptSegment(::capnp::Orphan< ::ucap::NodeSegment>&& value);
  inline ::capnp::Orphan< ::ucap::NodeSegment> disownSegment();

  inline bool hasMetadata();
  inline  ::ucap::Metadata::Builder getMetadata();
  inline void setMetadata( ::ucap::Metadata::Reader value);
  inline  ::ucap::Metadata::Builder initMetadata();
  inline void adoptMetadata(::capnp::Orphan< ::ucap::Metadata>&& value);
  inline ::capnp::Orphan< ::ucap::Metadata> disownMetadata();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Node::Pipeline {
public:
  typedef Node Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::ucap::NodeLoc::Pipeline getLoc();
  inline  ::ucap::NodeTiming::Pipeline getTiming();
  inline  ::ucap::NodeSegment::Pipeline getSegment();
  inline  ::ucap::Metadata::Pipeline getMetadata();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class RrNodes::Reader {
public:
  typedef RrNodes Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasNodes() const;
  inline  ::capnp::List< ::ucap::Node,  ::capnp::Kind::STRUCT>::Reader getNodes() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class RrNodes::Builder {
public:
  typedef RrNodes Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasNodes();
  inline  ::capnp::List< ::ucap::Node,  ::capnp::Kind::STRUCT>::Builder getNodes();
  inline void setNodes( ::capnp::List< ::ucap::Node,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::ucap::Node,  ::capnp::Kind::STRUCT>::Builder initNodes(unsigned int size);
  inline void adoptNodes(::capnp::Orphan< ::capnp::List< ::ucap::Node,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::ucap::Node,  ::capnp::Kind::STRUCT>> disownNodes();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class RrNodes::Pipeline {
public:
  typedef RrNodes Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Edge::Reader {
public:
  typedef Edge Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getSinkNode() const;

  inline  ::uint32_t getSrcNode() const;

  inline  ::uint32_t getSwitchId() const;

  inline bool hasMetadata() const;
  inline  ::ucap::Metadata::Reader getMetadata() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Edge::Builder {
public:
  typedef Edge Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getSinkNode();
  inline void setSinkNode( ::uint32_t value);

  inline  ::uint32_t getSrcNode();
  inline void setSrcNode( ::uint32_t value);

  inline  ::uint32_t getSwitchId();
  inline void setSwitchId( ::uint32_t value);

  inline bool hasMetadata();
  inline  ::ucap::Metadata::Builder getMetadata();
  inline void setMetadata( ::ucap::Metadata::Reader value);
  inline  ::ucap::Metadata::Builder initMetadata();
  inline void adoptMetadata(::capnp::Orphan< ::ucap::Metadata>&& value);
  inline ::capnp::Orphan< ::ucap::Metadata> disownMetadata();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Edge::Pipeline {
public:
  typedef Edge Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::ucap::Metadata::Pipeline getMetadata();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class RrEdges::Reader {
public:
  typedef RrEdges Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasEdges() const;
  inline  ::capnp::List< ::ucap::Edge,  ::capnp::Kind::STRUCT>::Reader getEdges() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class RrEdges::Builder {
public:
  typedef RrEdges Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasEdges();
  inline  ::capnp::List< ::ucap::Edge,  ::capnp::Kind::STRUCT>::Builder getEdges();
  inline void setEdges( ::capnp::List< ::ucap::Edge,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::ucap::Edge,  ::capnp::Kind::STRUCT>::Builder initEdges(unsigned int size);
  inline void adoptEdges(::capnp::Orphan< ::capnp::List< ::ucap::Edge,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::ucap::Edge,  ::capnp::Kind::STRUCT>> disownEdges();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class RrEdges::Pipeline {
public:
  typedef RrEdges Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class RrGraph::Reader {
public:
  typedef RrGraph Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasToolComment() const;
  inline  ::capnp::Text::Reader getToolComment() const;

  inline bool hasToolName() const;
  inline  ::capnp::Text::Reader getToolName() const;

  inline bool hasToolVersion() const;
  inline  ::capnp::Text::Reader getToolVersion() const;

  inline bool hasChannels() const;
  inline  ::ucap::Channels::Reader getChannels() const;

  inline bool hasSwitches() const;
  inline  ::ucap::Switches::Reader getSwitches() const;

  inline bool hasSegments() const;
  inline  ::ucap::Segments::Reader getSegments() const;

  inline bool hasBlockTypes() const;
  inline  ::ucap::BlockTypes::Reader getBlockTypes() const;

  inline bool hasGrid() const;
  inline  ::ucap::GridLocs::Reader getGrid() const;

  inline bool hasRrNodes() const;
  inline  ::ucap::RrNodes::Reader getRrNodes() const;

  inline bool hasRrEdges() const;
  inline  ::ucap::RrEdges::Reader getRrEdges() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class RrGraph::Builder {
public:
  typedef RrGraph Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasToolComment();
  inline  ::capnp::Text::Builder getToolComment();
  inline void setToolComment( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initToolComment(unsigned int size);
  inline void adoptToolComment(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownToolComment();

  inline bool hasToolName();
  inline  ::capnp::Text::Builder getToolName();
  inline void setToolName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initToolName(unsigned int size);
  inline void adoptToolName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownToolName();

  inline bool hasToolVersion();
  inline  ::capnp::Text::Builder getToolVersion();
  inline void setToolVersion( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initToolVersion(unsigned int size);
  inline void adoptToolVersion(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownToolVersion();

  inline bool hasChannels();
  inline  ::ucap::Channels::Builder getChannels();
  inline void setChannels( ::ucap::Channels::Reader value);
  inline  ::ucap::Channels::Builder initChannels();
  inline void adoptChannels(::capnp::Orphan< ::ucap::Channels>&& value);
  inline ::capnp::Orphan< ::ucap::Channels> disownChannels();

  inline bool hasSwitches();
  inline  ::ucap::Switches::Builder getSwitches();
  inline void setSwitches( ::ucap::Switches::Reader value);
  inline  ::ucap::Switches::Builder initSwitches();
  inline void adoptSwitches(::capnp::Orphan< ::ucap::Switches>&& value);
  inline ::capnp::Orphan< ::ucap::Switches> disownSwitches();

  inline bool hasSegments();
  inline  ::ucap::Segments::Builder getSegments();
  inline void setSegments( ::ucap::Segments::Reader value);
  inline  ::ucap::Segments::Builder initSegments();
  inline void adoptSegments(::capnp::Orphan< ::ucap::Segments>&& value);
  inline ::capnp::Orphan< ::ucap::Segments> disownSegments();

  inline bool hasBlockTypes();
  inline  ::ucap::BlockTypes::Builder getBlockTypes();
  inline void setBlockTypes( ::ucap::BlockTypes::Reader value);
  inline  ::ucap::BlockTypes::Builder initBlockTypes();
  inline void adoptBlockTypes(::capnp::Orphan< ::ucap::BlockTypes>&& value);
  inline ::capnp::Orphan< ::ucap::BlockTypes> disownBlockTypes();

  inline bool hasGrid();
  inline  ::ucap::GridLocs::Builder getGrid();
  inline void setGrid( ::ucap::GridLocs::Reader value);
  inline  ::ucap::GridLocs::Builder initGrid();
  inline void adoptGrid(::capnp::Orphan< ::ucap::GridLocs>&& value);
  inline ::capnp::Orphan< ::ucap::GridLocs> disownGrid();

  inline bool hasRrNodes();
  inline  ::ucap::RrNodes::Builder getRrNodes();
  inline void setRrNodes( ::ucap::RrNodes::Reader value);
  inline  ::ucap::RrNodes::Builder initRrNodes();
  inline void adoptRrNodes(::capnp::Orphan< ::ucap::RrNodes>&& value);
  inline ::capnp::Orphan< ::ucap::RrNodes> disownRrNodes();

  inline bool hasRrEdges();
  inline  ::ucap::RrEdges::Builder getRrEdges();
  inline void setRrEdges( ::ucap::RrEdges::Reader value);
  inline  ::ucap::RrEdges::Builder initRrEdges();
  inline void adoptRrEdges(::capnp::Orphan< ::ucap::RrEdges>&& value);
  inline ::capnp::Orphan< ::ucap::RrEdges> disownRrEdges();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class RrGraph::Pipeline {
public:
  typedef RrGraph Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::ucap::Channels::Pipeline getChannels();
  inline  ::ucap::Switches::Pipeline getSwitches();
  inline  ::ucap::Segments::Pipeline getSegments();
  inline  ::ucap::BlockTypes::Pipeline getBlockTypes();
  inline  ::ucap::GridLocs::Pipeline getGrid();
  inline  ::ucap::RrNodes::Pipeline getRrNodes();
  inline  ::ucap::RrEdges::Pipeline getRrEdges();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline  ::int32_t Channel::Reader::getChanWidthMax() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t Channel::Builder::getChanWidthMax() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Channel::Builder::setChanWidthMax( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t Channel::Reader::getXMax() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int32_t Channel::Builder::getXMax() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Channel::Builder::setXMax( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t Channel::Reader::getXMin() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::int32_t Channel::Builder::getXMin() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Channel::Builder::setXMin( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t Channel::Reader::getYMax() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::int32_t Channel::Builder::getYMax() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void Channel::Builder::setYMax( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t Channel::Reader::getYMin() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline  ::int32_t Channel::Builder::getYMin() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void Channel::Builder::setYMin( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t XList::Reader::getIndex() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t XList::Builder::getIndex() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void XList::Builder::setIndex( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t XList::Reader::getInfo() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int32_t XList::Builder::getInfo() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void XList::Builder::setInfo( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t YList::Reader::getIndex() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t YList::Builder::getIndex() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void YList::Builder::setIndex( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t YList::Reader::getInfo() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int32_t YList::Builder::getInfo() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void YList::Builder::setInfo( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Channels::Reader::hasChannel() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Channels::Builder::hasChannel() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::ucap::Channel::Reader Channels::Reader::getChannel() const {
  return ::capnp::_::PointerHelpers< ::ucap::Channel>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::ucap::Channel::Builder Channels::Builder::getChannel() {
  return ::capnp::_::PointerHelpers< ::ucap::Channel>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::ucap::Channel::Pipeline Channels::Pipeline::getChannel() {
  return  ::ucap::Channel::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Channels::Builder::setChannel( ::ucap::Channel::Reader value) {
  ::capnp::_::PointerHelpers< ::ucap::Channel>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::ucap::Channel::Builder Channels::Builder::initChannel() {
  return ::capnp::_::PointerHelpers< ::ucap::Channel>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Channels::Builder::adoptChannel(
    ::capnp::Orphan< ::ucap::Channel>&& value) {
  ::capnp::_::PointerHelpers< ::ucap::Channel>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::ucap::Channel> Channels::Builder::disownChannel() {
  return ::capnp::_::PointerHelpers< ::ucap::Channel>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Channels::Reader::hasXLists() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Channels::Builder::hasXLists() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::ucap::XList,  ::capnp::Kind::STRUCT>::Reader Channels::Reader::getXLists() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::XList,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::ucap::XList,  ::capnp::Kind::STRUCT>::Builder Channels::Builder::getXLists() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::XList,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Channels::Builder::setXLists( ::capnp::List< ::ucap::XList,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::XList,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::ucap::XList,  ::capnp::Kind::STRUCT>::Builder Channels::Builder::initXLists(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::XList,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Channels::Builder::adoptXLists(
    ::capnp::Orphan< ::capnp::List< ::ucap::XList,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::XList,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::ucap::XList,  ::capnp::Kind::STRUCT>> Channels::Builder::disownXLists() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::XList,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Channels::Reader::hasYLists() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Channels::Builder::hasYLists() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::ucap::YList,  ::capnp::Kind::STRUCT>::Reader Channels::Reader::getYLists() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::YList,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::ucap::YList,  ::capnp::Kind::STRUCT>::Builder Channels::Builder::getYLists() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::YList,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Channels::Builder::setYLists( ::capnp::List< ::ucap::YList,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::YList,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::ucap::YList,  ::capnp::Kind::STRUCT>::Builder Channels::Builder::initYLists(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::YList,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void Channels::Builder::adoptYLists(
    ::capnp::Orphan< ::capnp::List< ::ucap::YList,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::YList,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::ucap::YList,  ::capnp::Kind::STRUCT>> Channels::Builder::disownYLists() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::YList,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline float Timing::Reader::getCin() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float Timing::Builder::getCin() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Timing::Builder::setCin(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float Timing::Reader::getCinternal() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float Timing::Builder::getCinternal() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Timing::Builder::setCinternal(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float Timing::Reader::getCout() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline float Timing::Builder::getCout() {
  return _builder.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Timing::Builder::setCout(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline float Timing::Reader::getR() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline float Timing::Builder::getR() {
  return _builder.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void Timing::Builder::setR(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline float Timing::Reader::getTdel() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline float Timing::Builder::getTdel() {
  return _builder.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void Timing::Builder::setTdel(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline float Sizing::Reader::getBufSize() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float Sizing::Builder::getBufSize() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Sizing::Builder::setBufSize(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float Sizing::Reader::getMuxTransSize() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float Sizing::Builder::getMuxTransSize() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Sizing::Builder::setMuxTransSize(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t Switch::Reader::getId() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t Switch::Builder::getId() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Switch::Builder::setId( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Switch::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Switch::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Switch::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Switch::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Switch::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Switch::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Switch::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Switch::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::ucap::SwitchType Switch::Reader::getType() const {
  return _reader.getDataField< ::ucap::SwitchType>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::ucap::SwitchType Switch::Builder::getType() {
  return _builder.getDataField< ::ucap::SwitchType>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Switch::Builder::setType( ::ucap::SwitchType value) {
  _builder.setDataField< ::ucap::SwitchType>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool Switch::Reader::hasTiming() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Switch::Builder::hasTiming() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::ucap::Timing::Reader Switch::Reader::getTiming() const {
  return ::capnp::_::PointerHelpers< ::ucap::Timing>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::ucap::Timing::Builder Switch::Builder::getTiming() {
  return ::capnp::_::PointerHelpers< ::ucap::Timing>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::ucap::Timing::Pipeline Switch::Pipeline::getTiming() {
  return  ::ucap::Timing::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Switch::Builder::setTiming( ::ucap::Timing::Reader value) {
  ::capnp::_::PointerHelpers< ::ucap::Timing>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::ucap::Timing::Builder Switch::Builder::initTiming() {
  return ::capnp::_::PointerHelpers< ::ucap::Timing>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Switch::Builder::adoptTiming(
    ::capnp::Orphan< ::ucap::Timing>&& value) {
  ::capnp::_::PointerHelpers< ::ucap::Timing>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::ucap::Timing> Switch::Builder::disownTiming() {
  return ::capnp::_::PointerHelpers< ::ucap::Timing>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Switch::Reader::hasSizing() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Switch::Builder::hasSizing() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::ucap::Sizing::Reader Switch::Reader::getSizing() const {
  return ::capnp::_::PointerHelpers< ::ucap::Sizing>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::ucap::Sizing::Builder Switch::Builder::getSizing() {
  return ::capnp::_::PointerHelpers< ::ucap::Sizing>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::ucap::Sizing::Pipeline Switch::Pipeline::getSizing() {
  return  ::ucap::Sizing::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void Switch::Builder::setSizing( ::ucap::Sizing::Reader value) {
  ::capnp::_::PointerHelpers< ::ucap::Sizing>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::ucap::Sizing::Builder Switch::Builder::initSizing() {
  return ::capnp::_::PointerHelpers< ::ucap::Sizing>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Switch::Builder::adoptSizing(
    ::capnp::Orphan< ::ucap::Sizing>&& value) {
  ::capnp::_::PointerHelpers< ::ucap::Sizing>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::ucap::Sizing> Switch::Builder::disownSizing() {
  return ::capnp::_::PointerHelpers< ::ucap::Sizing>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool Switches::Reader::hasSwitches() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Switches::Builder::hasSwitches() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::ucap::Switch,  ::capnp::Kind::STRUCT>::Reader Switches::Reader::getSwitches() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::Switch,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::ucap::Switch,  ::capnp::Kind::STRUCT>::Builder Switches::Builder::getSwitches() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::Switch,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Switches::Builder::setSwitches( ::capnp::List< ::ucap::Switch,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::Switch,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::ucap::Switch,  ::capnp::Kind::STRUCT>::Builder Switches::Builder::initSwitches(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::Switch,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Switches::Builder::adoptSwitches(
    ::capnp::Orphan< ::capnp::List< ::ucap::Switch,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::Switch,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::ucap::Switch,  ::capnp::Kind::STRUCT>> Switches::Builder::disownSwitches() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::Switch,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline float SegmentTiming::Reader::getCPerMeter() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float SegmentTiming::Builder::getCPerMeter() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void SegmentTiming::Builder::setCPerMeter(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float SegmentTiming::Reader::getRPerMeter() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float SegmentTiming::Builder::getRPerMeter() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void SegmentTiming::Builder::setRPerMeter(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t Segment::Reader::getId() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t Segment::Builder::getId() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Segment::Builder::setId( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Segment::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Segment::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Segment::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Segment::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Segment::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Segment::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Segment::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Segment::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Segment::Reader::hasTiming() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Segment::Builder::hasTiming() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::ucap::SegmentTiming::Reader Segment::Reader::getTiming() const {
  return ::capnp::_::PointerHelpers< ::ucap::SegmentTiming>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::ucap::SegmentTiming::Builder Segment::Builder::getTiming() {
  return ::capnp::_::PointerHelpers< ::ucap::SegmentTiming>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::ucap::SegmentTiming::Pipeline Segment::Pipeline::getTiming() {
  return  ::ucap::SegmentTiming::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Segment::Builder::setTiming( ::ucap::SegmentTiming::Reader value) {
  ::capnp::_::PointerHelpers< ::ucap::SegmentTiming>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::ucap::SegmentTiming::Builder Segment::Builder::initTiming() {
  return ::capnp::_::PointerHelpers< ::ucap::SegmentTiming>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Segment::Builder::adoptTiming(
    ::capnp::Orphan< ::ucap::SegmentTiming>&& value) {
  ::capnp::_::PointerHelpers< ::ucap::SegmentTiming>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::ucap::SegmentTiming> Segment::Builder::disownTiming() {
  return ::capnp::_::PointerHelpers< ::ucap::SegmentTiming>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Segments::Reader::hasSegments() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Segments::Builder::hasSegments() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::ucap::Segment,  ::capnp::Kind::STRUCT>::Reader Segments::Reader::getSegments() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::Segment,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::ucap::Segment,  ::capnp::Kind::STRUCT>::Builder Segments::Builder::getSegments() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::Segment,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Segments::Builder::setSegments( ::capnp::List< ::ucap::Segment,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::Segment,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::ucap::Segment,  ::capnp::Kind::STRUCT>::Builder Segments::Builder::initSegments(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::Segment,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Segments::Builder::adoptSegments(
    ::capnp::Orphan< ::capnp::List< ::ucap::Segment,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::Segment,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::ucap::Segment,  ::capnp::Kind::STRUCT>> Segments::Builder::disownSegments() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::Segment,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::int32_t Pin::Reader::getPtc() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t Pin::Builder::getPtc() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Pin::Builder::setPtc( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Pin::Reader::hasValue() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Pin::Builder::hasValue() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Pin::Reader::getValue() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Pin::Builder::getValue() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Pin::Builder::setValue( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Pin::Builder::initValue(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Pin::Builder::adoptValue(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Pin::Builder::disownValue() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::ucap::PinType PinClass::Reader::getType() const {
  return _reader.getDataField< ::ucap::PinType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::ucap::PinType PinClass::Builder::getType() {
  return _builder.getDataField< ::ucap::PinType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void PinClass::Builder::setType( ::ucap::PinType value) {
  _builder.setDataField< ::ucap::PinType>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool PinClass::Reader::hasPins() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool PinClass::Builder::hasPins() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::ucap::Pin,  ::capnp::Kind::STRUCT>::Reader PinClass::Reader::getPins() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::Pin,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::ucap::Pin,  ::capnp::Kind::STRUCT>::Builder PinClass::Builder::getPins() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::Pin,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void PinClass::Builder::setPins( ::capnp::List< ::ucap::Pin,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::Pin,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::ucap::Pin,  ::capnp::Kind::STRUCT>::Builder PinClass::Builder::initPins(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::Pin,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void PinClass::Builder::adoptPins(
    ::capnp::Orphan< ::capnp::List< ::ucap::Pin,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::Pin,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::ucap::Pin,  ::capnp::Kind::STRUCT>> PinClass::Builder::disownPins() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::Pin,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::int32_t BlockType::Reader::getHeight() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t BlockType::Builder::getHeight() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void BlockType::Builder::setHeight( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t BlockType::Reader::getId() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int32_t BlockType::Builder::getId() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void BlockType::Builder::setId( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool BlockType::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool BlockType::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader BlockType::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder BlockType::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void BlockType::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder BlockType::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void BlockType::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> BlockType::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::int32_t BlockType::Reader::getWidth() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::int32_t BlockType::Builder::getWidth() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void BlockType::Builder::setWidth( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool BlockType::Reader::hasPinClasses() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool BlockType::Builder::hasPinClasses() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::ucap::PinClass,  ::capnp::Kind::STRUCT>::Reader BlockType::Reader::getPinClasses() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::PinClass,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::ucap::PinClass,  ::capnp::Kind::STRUCT>::Builder BlockType::Builder::getPinClasses() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::PinClass,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void BlockType::Builder::setPinClasses( ::capnp::List< ::ucap::PinClass,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::PinClass,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::ucap::PinClass,  ::capnp::Kind::STRUCT>::Builder BlockType::Builder::initPinClasses(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::PinClass,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void BlockType::Builder::adoptPinClasses(
    ::capnp::Orphan< ::capnp::List< ::ucap::PinClass,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::PinClass,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::ucap::PinClass,  ::capnp::Kind::STRUCT>> BlockType::Builder::disownPinClasses() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::PinClass,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool BlockTypes::Reader::hasBlockTypes() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool BlockTypes::Builder::hasBlockTypes() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::ucap::BlockType,  ::capnp::Kind::STRUCT>::Reader BlockTypes::Reader::getBlockTypes() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::BlockType,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::ucap::BlockType,  ::capnp::Kind::STRUCT>::Builder BlockTypes::Builder::getBlockTypes() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::BlockType,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void BlockTypes::Builder::setBlockTypes( ::capnp::List< ::ucap::BlockType,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::BlockType,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::ucap::BlockType,  ::capnp::Kind::STRUCT>::Builder BlockTypes::Builder::initBlockTypes(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::BlockType,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void BlockTypes::Builder::adoptBlockTypes(
    ::capnp::Orphan< ::capnp::List< ::ucap::BlockType,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::BlockType,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::ucap::BlockType,  ::capnp::Kind::STRUCT>> BlockTypes::Builder::disownBlockTypes() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::BlockType,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::int32_t GridLoc::Reader::getBlockTypeId() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t GridLoc::Builder::getBlockTypeId() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void GridLoc::Builder::setBlockTypeId( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t GridLoc::Reader::getHeightOffset() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int32_t GridLoc::Builder::getHeightOffset() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void GridLoc::Builder::setHeightOffset( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t GridLoc::Reader::getWidthOffset() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::int32_t GridLoc::Builder::getWidthOffset() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void GridLoc::Builder::setWidthOffset( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t GridLoc::Reader::getX() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::int32_t GridLoc::Builder::getX() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void GridLoc::Builder::setX( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t GridLoc::Reader::getY() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline  ::int32_t GridLoc::Builder::getY() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void GridLoc::Builder::setY( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline bool GridLocs::Reader::hasGridLocs() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool GridLocs::Builder::hasGridLocs() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::ucap::GridLoc,  ::capnp::Kind::STRUCT>::Reader GridLocs::Reader::getGridLocs() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::GridLoc,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::ucap::GridLoc,  ::capnp::Kind::STRUCT>::Builder GridLocs::Builder::getGridLocs() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::GridLoc,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void GridLocs::Builder::setGridLocs( ::capnp::List< ::ucap::GridLoc,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::GridLoc,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::ucap::GridLoc,  ::capnp::Kind::STRUCT>::Builder GridLocs::Builder::initGridLocs(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::GridLoc,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void GridLocs::Builder::adoptGridLocs(
    ::capnp::Orphan< ::capnp::List< ::ucap::GridLoc,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::GridLoc,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::ucap::GridLoc,  ::capnp::Kind::STRUCT>> GridLocs::Builder::disownGridLocs() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::GridLoc,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::int32_t NodeLoc::Reader::getPtc() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t NodeLoc::Builder::getPtc() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void NodeLoc::Builder::setPtc( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::ucap::LocSide NodeLoc::Reader::getSide() const {
  return _reader.getDataField< ::ucap::LocSide>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::ucap::LocSide NodeLoc::Builder::getSide() {
  return _builder.getDataField< ::ucap::LocSide>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void NodeLoc::Builder::setSide( ::ucap::LocSide value) {
  _builder.setDataField< ::ucap::LocSide>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t NodeLoc::Reader::getXhigh() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::int32_t NodeLoc::Builder::getXhigh() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void NodeLoc::Builder::setXhigh( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t NodeLoc::Reader::getXlow() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::int32_t NodeLoc::Builder::getXlow() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void NodeLoc::Builder::setXlow( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t NodeLoc::Reader::getYhigh() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline  ::int32_t NodeLoc::Builder::getYhigh() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void NodeLoc::Builder::setYhigh( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t NodeLoc::Reader::getYlow() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline  ::int32_t NodeLoc::Builder::getYlow() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline void NodeLoc::Builder::setYlow( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value);
}

inline float NodeTiming::Reader::getC() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float NodeTiming::Builder::getC() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void NodeTiming::Builder::setC(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float NodeTiming::Reader::getR() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float NodeTiming::Builder::getR() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void NodeTiming::Builder::setR(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t NodeSegment::Reader::getSegmentId() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t NodeSegment::Builder::getSegmentId() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void NodeSegment::Builder::setSegmentId( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Meta::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Meta::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Meta::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Meta::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Meta::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Meta::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Meta::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Meta::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Meta::Reader::hasValue() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Meta::Builder::hasValue() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Meta::Reader::getValue() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Meta::Builder::getValue() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Meta::Builder::setValue( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Meta::Builder::initValue(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Meta::Builder::adoptValue(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Meta::Builder::disownValue() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Metadata::Reader::hasMetas() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Metadata::Builder::hasMetas() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::ucap::Meta,  ::capnp::Kind::STRUCT>::Reader Metadata::Reader::getMetas() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::Meta,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::ucap::Meta,  ::capnp::Kind::STRUCT>::Builder Metadata::Builder::getMetas() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::Meta,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Metadata::Builder::setMetas( ::capnp::List< ::ucap::Meta,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::Meta,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::ucap::Meta,  ::capnp::Kind::STRUCT>::Builder Metadata::Builder::initMetas(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::Meta,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Metadata::Builder::adoptMetas(
    ::capnp::Orphan< ::capnp::List< ::ucap::Meta,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::Meta,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::ucap::Meta,  ::capnp::Kind::STRUCT>> Metadata::Builder::disownMetas() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::Meta,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint32_t Node::Reader::getCapacity() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Node::Builder::getCapacity() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Node::Builder::setCapacity( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::ucap::NodeDirection Node::Reader::getDirection() const {
  return _reader.getDataField< ::ucap::NodeDirection>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::ucap::NodeDirection Node::Builder::getDirection() {
  return _builder.getDataField< ::ucap::NodeDirection>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Node::Builder::setDirection( ::ucap::NodeDirection value) {
  _builder.setDataField< ::ucap::NodeDirection>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Node::Reader::getId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Node::Builder::getId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Node::Builder::setId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::ucap::NodeType Node::Reader::getType() const {
  return _reader.getDataField< ::ucap::NodeType>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::ucap::NodeType Node::Builder::getType() {
  return _builder.getDataField< ::ucap::NodeType>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void Node::Builder::setType( ::ucap::NodeType value) {
  _builder.setDataField< ::ucap::NodeType>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline bool Node::Reader::hasLoc() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Node::Builder::hasLoc() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::ucap::NodeLoc::Reader Node::Reader::getLoc() const {
  return ::capnp::_::PointerHelpers< ::ucap::NodeLoc>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::ucap::NodeLoc::Builder Node::Builder::getLoc() {
  return ::capnp::_::PointerHelpers< ::ucap::NodeLoc>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::ucap::NodeLoc::Pipeline Node::Pipeline::getLoc() {
  return  ::ucap::NodeLoc::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Node::Builder::setLoc( ::ucap::NodeLoc::Reader value) {
  ::capnp::_::PointerHelpers< ::ucap::NodeLoc>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::ucap::NodeLoc::Builder Node::Builder::initLoc() {
  return ::capnp::_::PointerHelpers< ::ucap::NodeLoc>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Node::Builder::adoptLoc(
    ::capnp::Orphan< ::ucap::NodeLoc>&& value) {
  ::capnp::_::PointerHelpers< ::ucap::NodeLoc>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::ucap::NodeLoc> Node::Builder::disownLoc() {
  return ::capnp::_::PointerHelpers< ::ucap::NodeLoc>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Node::Reader::hasTiming() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Node::Builder::hasTiming() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::ucap::NodeTiming::Reader Node::Reader::getTiming() const {
  return ::capnp::_::PointerHelpers< ::ucap::NodeTiming>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::ucap::NodeTiming::Builder Node::Builder::getTiming() {
  return ::capnp::_::PointerHelpers< ::ucap::NodeTiming>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::ucap::NodeTiming::Pipeline Node::Pipeline::getTiming() {
  return  ::ucap::NodeTiming::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Node::Builder::setTiming( ::ucap::NodeTiming::Reader value) {
  ::capnp::_::PointerHelpers< ::ucap::NodeTiming>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::ucap::NodeTiming::Builder Node::Builder::initTiming() {
  return ::capnp::_::PointerHelpers< ::ucap::NodeTiming>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Node::Builder::adoptTiming(
    ::capnp::Orphan< ::ucap::NodeTiming>&& value) {
  ::capnp::_::PointerHelpers< ::ucap::NodeTiming>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::ucap::NodeTiming> Node::Builder::disownTiming() {
  return ::capnp::_::PointerHelpers< ::ucap::NodeTiming>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Node::Reader::hasSegment() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Node::Builder::hasSegment() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::ucap::NodeSegment::Reader Node::Reader::getSegment() const {
  return ::capnp::_::PointerHelpers< ::ucap::NodeSegment>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::ucap::NodeSegment::Builder Node::Builder::getSegment() {
  return ::capnp::_::PointerHelpers< ::ucap::NodeSegment>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::ucap::NodeSegment::Pipeline Node::Pipeline::getSegment() {
  return  ::ucap::NodeSegment::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void Node::Builder::setSegment( ::ucap::NodeSegment::Reader value) {
  ::capnp::_::PointerHelpers< ::ucap::NodeSegment>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::ucap::NodeSegment::Builder Node::Builder::initSegment() {
  return ::capnp::_::PointerHelpers< ::ucap::NodeSegment>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Node::Builder::adoptSegment(
    ::capnp::Orphan< ::ucap::NodeSegment>&& value) {
  ::capnp::_::PointerHelpers< ::ucap::NodeSegment>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::ucap::NodeSegment> Node::Builder::disownSegment() {
  return ::capnp::_::PointerHelpers< ::ucap::NodeSegment>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool Node::Reader::hasMetadata() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool Node::Builder::hasMetadata() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::ucap::Metadata::Reader Node::Reader::getMetadata() const {
  return ::capnp::_::PointerHelpers< ::ucap::Metadata>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::ucap::Metadata::Builder Node::Builder::getMetadata() {
  return ::capnp::_::PointerHelpers< ::ucap::Metadata>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::ucap::Metadata::Pipeline Node::Pipeline::getMetadata() {
  return  ::ucap::Metadata::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void Node::Builder::setMetadata( ::ucap::Metadata::Reader value) {
  ::capnp::_::PointerHelpers< ::ucap::Metadata>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::ucap::Metadata::Builder Node::Builder::initMetadata() {
  return ::capnp::_::PointerHelpers< ::ucap::Metadata>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Node::Builder::adoptMetadata(
    ::capnp::Orphan< ::ucap::Metadata>&& value) {
  ::capnp::_::PointerHelpers< ::ucap::Metadata>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::ucap::Metadata> Node::Builder::disownMetadata() {
  return ::capnp::_::PointerHelpers< ::ucap::Metadata>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool RrNodes::Reader::hasNodes() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool RrNodes::Builder::hasNodes() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::ucap::Node,  ::capnp::Kind::STRUCT>::Reader RrNodes::Reader::getNodes() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::Node,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::ucap::Node,  ::capnp::Kind::STRUCT>::Builder RrNodes::Builder::getNodes() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::Node,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void RrNodes::Builder::setNodes( ::capnp::List< ::ucap::Node,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::Node,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::ucap::Node,  ::capnp::Kind::STRUCT>::Builder RrNodes::Builder::initNodes(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::Node,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void RrNodes::Builder::adoptNodes(
    ::capnp::Orphan< ::capnp::List< ::ucap::Node,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::Node,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::ucap::Node,  ::capnp::Kind::STRUCT>> RrNodes::Builder::disownNodes() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::Node,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint32_t Edge::Reader::getSinkNode() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Edge::Builder::getSinkNode() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Edge::Builder::setSinkNode( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Edge::Reader::getSrcNode() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Edge::Builder::getSrcNode() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Edge::Builder::setSrcNode( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Edge::Reader::getSwitchId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Edge::Builder::getSwitchId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Edge::Builder::setSwitchId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool Edge::Reader::hasMetadata() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Edge::Builder::hasMetadata() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::ucap::Metadata::Reader Edge::Reader::getMetadata() const {
  return ::capnp::_::PointerHelpers< ::ucap::Metadata>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::ucap::Metadata::Builder Edge::Builder::getMetadata() {
  return ::capnp::_::PointerHelpers< ::ucap::Metadata>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::ucap::Metadata::Pipeline Edge::Pipeline::getMetadata() {
  return  ::ucap::Metadata::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Edge::Builder::setMetadata( ::ucap::Metadata::Reader value) {
  ::capnp::_::PointerHelpers< ::ucap::Metadata>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::ucap::Metadata::Builder Edge::Builder::initMetadata() {
  return ::capnp::_::PointerHelpers< ::ucap::Metadata>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Edge::Builder::adoptMetadata(
    ::capnp::Orphan< ::ucap::Metadata>&& value) {
  ::capnp::_::PointerHelpers< ::ucap::Metadata>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::ucap::Metadata> Edge::Builder::disownMetadata() {
  return ::capnp::_::PointerHelpers< ::ucap::Metadata>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool RrEdges::Reader::hasEdges() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool RrEdges::Builder::hasEdges() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::ucap::Edge,  ::capnp::Kind::STRUCT>::Reader RrEdges::Reader::getEdges() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::Edge,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::ucap::Edge,  ::capnp::Kind::STRUCT>::Builder RrEdges::Builder::getEdges() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::Edge,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void RrEdges::Builder::setEdges( ::capnp::List< ::ucap::Edge,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::Edge,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::ucap::Edge,  ::capnp::Kind::STRUCT>::Builder RrEdges::Builder::initEdges(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::Edge,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void RrEdges::Builder::adoptEdges(
    ::capnp::Orphan< ::capnp::List< ::ucap::Edge,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::Edge,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::ucap::Edge,  ::capnp::Kind::STRUCT>> RrEdges::Builder::disownEdges() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::ucap::Edge,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool RrGraph::Reader::hasToolComment() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool RrGraph::Builder::hasToolComment() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader RrGraph::Reader::getToolComment() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder RrGraph::Builder::getToolComment() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void RrGraph::Builder::setToolComment( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder RrGraph::Builder::initToolComment(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void RrGraph::Builder::adoptToolComment(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> RrGraph::Builder::disownToolComment() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool RrGraph::Reader::hasToolName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool RrGraph::Builder::hasToolName() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader RrGraph::Reader::getToolName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder RrGraph::Builder::getToolName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void RrGraph::Builder::setToolName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder RrGraph::Builder::initToolName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void RrGraph::Builder::adoptToolName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> RrGraph::Builder::disownToolName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool RrGraph::Reader::hasToolVersion() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool RrGraph::Builder::hasToolVersion() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader RrGraph::Reader::getToolVersion() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder RrGraph::Builder::getToolVersion() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void RrGraph::Builder::setToolVersion( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder RrGraph::Builder::initToolVersion(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void RrGraph::Builder::adoptToolVersion(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> RrGraph::Builder::disownToolVersion() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool RrGraph::Reader::hasChannels() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool RrGraph::Builder::hasChannels() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::ucap::Channels::Reader RrGraph::Reader::getChannels() const {
  return ::capnp::_::PointerHelpers< ::ucap::Channels>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::ucap::Channels::Builder RrGraph::Builder::getChannels() {
  return ::capnp::_::PointerHelpers< ::ucap::Channels>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::ucap::Channels::Pipeline RrGraph::Pipeline::getChannels() {
  return  ::ucap::Channels::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void RrGraph::Builder::setChannels( ::ucap::Channels::Reader value) {
  ::capnp::_::PointerHelpers< ::ucap::Channels>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::ucap::Channels::Builder RrGraph::Builder::initChannels() {
  return ::capnp::_::PointerHelpers< ::ucap::Channels>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void RrGraph::Builder::adoptChannels(
    ::capnp::Orphan< ::ucap::Channels>&& value) {
  ::capnp::_::PointerHelpers< ::ucap::Channels>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::ucap::Channels> RrGraph::Builder::disownChannels() {
  return ::capnp::_::PointerHelpers< ::ucap::Channels>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool RrGraph::Reader::hasSwitches() const {
  return !_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline bool RrGraph::Builder::hasSwitches() {
  return !_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline  ::ucap::Switches::Reader RrGraph::Reader::getSwitches() const {
  return ::capnp::_::PointerHelpers< ::ucap::Switches>::get(_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline  ::ucap::Switches::Builder RrGraph::Builder::getSwitches() {
  return ::capnp::_::PointerHelpers< ::ucap::Switches>::get(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::ucap::Switches::Pipeline RrGraph::Pipeline::getSwitches() {
  return  ::ucap::Switches::Pipeline(_typeless.getPointerField(4));
}
#endif  // !CAPNP_LITE
inline void RrGraph::Builder::setSwitches( ::ucap::Switches::Reader value) {
  ::capnp::_::PointerHelpers< ::ucap::Switches>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
inline  ::ucap::Switches::Builder RrGraph::Builder::initSwitches() {
  return ::capnp::_::PointerHelpers< ::ucap::Switches>::init(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline void RrGraph::Builder::adoptSwitches(
    ::capnp::Orphan< ::ucap::Switches>&& value) {
  ::capnp::_::PointerHelpers< ::ucap::Switches>::adopt(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::ucap::Switches> RrGraph::Builder::disownSwitches() {
  return ::capnp::_::PointerHelpers< ::ucap::Switches>::disown(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}

inline bool RrGraph::Reader::hasSegments() const {
  return !_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline bool RrGraph::Builder::hasSegments() {
  return !_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline  ::ucap::Segments::Reader RrGraph::Reader::getSegments() const {
  return ::capnp::_::PointerHelpers< ::ucap::Segments>::get(_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline  ::ucap::Segments::Builder RrGraph::Builder::getSegments() {
  return ::capnp::_::PointerHelpers< ::ucap::Segments>::get(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::ucap::Segments::Pipeline RrGraph::Pipeline::getSegments() {
  return  ::ucap::Segments::Pipeline(_typeless.getPointerField(5));
}
#endif  // !CAPNP_LITE
inline void RrGraph::Builder::setSegments( ::ucap::Segments::Reader value) {
  ::capnp::_::PointerHelpers< ::ucap::Segments>::set(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), value);
}
inline  ::ucap::Segments::Builder RrGraph::Builder::initSegments() {
  return ::capnp::_::PointerHelpers< ::ucap::Segments>::init(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline void RrGraph::Builder::adoptSegments(
    ::capnp::Orphan< ::ucap::Segments>&& value) {
  ::capnp::_::PointerHelpers< ::ucap::Segments>::adopt(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::ucap::Segments> RrGraph::Builder::disownSegments() {
  return ::capnp::_::PointerHelpers< ::ucap::Segments>::disown(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}

inline bool RrGraph::Reader::hasBlockTypes() const {
  return !_reader.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS).isNull();
}
inline bool RrGraph::Builder::hasBlockTypes() {
  return !_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS).isNull();
}
inline  ::ucap::BlockTypes::Reader RrGraph::Reader::getBlockTypes() const {
  return ::capnp::_::PointerHelpers< ::ucap::BlockTypes>::get(_reader.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
inline  ::ucap::BlockTypes::Builder RrGraph::Builder::getBlockTypes() {
  return ::capnp::_::PointerHelpers< ::ucap::BlockTypes>::get(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::ucap::BlockTypes::Pipeline RrGraph::Pipeline::getBlockTypes() {
  return  ::ucap::BlockTypes::Pipeline(_typeless.getPointerField(6));
}
#endif  // !CAPNP_LITE
inline void RrGraph::Builder::setBlockTypes( ::ucap::BlockTypes::Reader value) {
  ::capnp::_::PointerHelpers< ::ucap::BlockTypes>::set(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), value);
}
inline  ::ucap::BlockTypes::Builder RrGraph::Builder::initBlockTypes() {
  return ::capnp::_::PointerHelpers< ::ucap::BlockTypes>::init(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
inline void RrGraph::Builder::adoptBlockTypes(
    ::capnp::Orphan< ::ucap::BlockTypes>&& value) {
  ::capnp::_::PointerHelpers< ::ucap::BlockTypes>::adopt(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::ucap::BlockTypes> RrGraph::Builder::disownBlockTypes() {
  return ::capnp::_::PointerHelpers< ::ucap::BlockTypes>::disown(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}

inline bool RrGraph::Reader::hasGrid() const {
  return !_reader.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS).isNull();
}
inline bool RrGraph::Builder::hasGrid() {
  return !_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS).isNull();
}
inline  ::ucap::GridLocs::Reader RrGraph::Reader::getGrid() const {
  return ::capnp::_::PointerHelpers< ::ucap::GridLocs>::get(_reader.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}
inline  ::ucap::GridLocs::Builder RrGraph::Builder::getGrid() {
  return ::capnp::_::PointerHelpers< ::ucap::GridLocs>::get(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::ucap::GridLocs::Pipeline RrGraph::Pipeline::getGrid() {
  return  ::ucap::GridLocs::Pipeline(_typeless.getPointerField(7));
}
#endif  // !CAPNP_LITE
inline void RrGraph::Builder::setGrid( ::ucap::GridLocs::Reader value) {
  ::capnp::_::PointerHelpers< ::ucap::GridLocs>::set(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS), value);
}
inline  ::ucap::GridLocs::Builder RrGraph::Builder::initGrid() {
  return ::capnp::_::PointerHelpers< ::ucap::GridLocs>::init(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}
inline void RrGraph::Builder::adoptGrid(
    ::capnp::Orphan< ::ucap::GridLocs>&& value) {
  ::capnp::_::PointerHelpers< ::ucap::GridLocs>::adopt(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::ucap::GridLocs> RrGraph::Builder::disownGrid() {
  return ::capnp::_::PointerHelpers< ::ucap::GridLocs>::disown(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}

inline bool RrGraph::Reader::hasRrNodes() const {
  return !_reader.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS).isNull();
}
inline bool RrGraph::Builder::hasRrNodes() {
  return !_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS).isNull();
}
inline  ::ucap::RrNodes::Reader RrGraph::Reader::getRrNodes() const {
  return ::capnp::_::PointerHelpers< ::ucap::RrNodes>::get(_reader.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}
inline  ::ucap::RrNodes::Builder RrGraph::Builder::getRrNodes() {
  return ::capnp::_::PointerHelpers< ::ucap::RrNodes>::get(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::ucap::RrNodes::Pipeline RrGraph::Pipeline::getRrNodes() {
  return  ::ucap::RrNodes::Pipeline(_typeless.getPointerField(8));
}
#endif  // !CAPNP_LITE
inline void RrGraph::Builder::setRrNodes( ::ucap::RrNodes::Reader value) {
  ::capnp::_::PointerHelpers< ::ucap::RrNodes>::set(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS), value);
}
inline  ::ucap::RrNodes::Builder RrGraph::Builder::initRrNodes() {
  return ::capnp::_::PointerHelpers< ::ucap::RrNodes>::init(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}
inline void RrGraph::Builder::adoptRrNodes(
    ::capnp::Orphan< ::ucap::RrNodes>&& value) {
  ::capnp::_::PointerHelpers< ::ucap::RrNodes>::adopt(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::ucap::RrNodes> RrGraph::Builder::disownRrNodes() {
  return ::capnp::_::PointerHelpers< ::ucap::RrNodes>::disown(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}

inline bool RrGraph::Reader::hasRrEdges() const {
  return !_reader.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS).isNull();
}
inline bool RrGraph::Builder::hasRrEdges() {
  return !_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS).isNull();
}
inline  ::ucap::RrEdges::Reader RrGraph::Reader::getRrEdges() const {
  return ::capnp::_::PointerHelpers< ::ucap::RrEdges>::get(_reader.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS));
}
inline  ::ucap::RrEdges::Builder RrGraph::Builder::getRrEdges() {
  return ::capnp::_::PointerHelpers< ::ucap::RrEdges>::get(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::ucap::RrEdges::Pipeline RrGraph::Pipeline::getRrEdges() {
  return  ::ucap::RrEdges::Pipeline(_typeless.getPointerField(9));
}
#endif  // !CAPNP_LITE
inline void RrGraph::Builder::setRrEdges( ::ucap::RrEdges::Reader value) {
  ::capnp::_::PointerHelpers< ::ucap::RrEdges>::set(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS), value);
}
inline  ::ucap::RrEdges::Builder RrGraph::Builder::initRrEdges() {
  return ::capnp::_::PointerHelpers< ::ucap::RrEdges>::init(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS));
}
inline void RrGraph::Builder::adoptRrEdges(
    ::capnp::Orphan< ::ucap::RrEdges>&& value) {
  ::capnp::_::PointerHelpers< ::ucap::RrEdges>::adopt(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::ucap::RrEdges> RrGraph::Builder::disownRrEdges() {
  return ::capnp::_::PointerHelpers< ::ucap::RrEdges>::disown(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS));
}

}  // namespace

CAPNP_END_HEADER

